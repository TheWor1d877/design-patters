# design-patters
## 单例模式
✅ 用：全局唯一且状态可共享（日志器、配置表、硬件句柄）。
❌ 避：
– 为了“方便全局访问”而随手单例 → 隐藏依赖，单元测试难。
– 单例里存业务状态 → 并发测试变成“状态地雷”。

现代技巧：
– 优先用 std::call_once/static T 而不是双重检查锁。
– 考虑 constexpr 单例（C++20 constinit）对编译期初始化的场景。

- 使用场景
  我们日志器需要全局唯一实例，否则多线程写同一个文件会相互覆盖；
  同时它在整个进程生命周期都要存在，所以用单例管理最合适

- 测试友好
  “单例一旦初始化就无法重置，单元测试之间会互相污染。
  加了一个 测试专用 reset 接口，只在编译宏 UNIT_TEST 时暴露，
  这样每条测试用例都能拿到全新实例，CI 跑并行 job 也安全。”

- 反模式”自检
  单例如果存业务状态或被到处直接拿，就会变成隐形全局变量，
  所以只把单例用在 无业务状态、只负责***功能聚合***的类上

## 工厂模式
“把对象创建和使用解耦，让变化只关在一扇门里，其余代码永远开闭原则。”

#### 什么时候“值得”上工厂
创建逻辑可能变化
- 跨平台：Win/Linux/Mac 按钮
- 多数据源：MySQL/PostgreSQL/Oracle 连接
- 运行时决定：根据配置或用户输入选具体类

创建过程复杂，调用者只关心接口
- 需要参数校验、对象池、缓存、代理包装、埋点统计……
- 一句话：“new 完还得做一堆额外工序”

#### 工厂模式的特点
- 创建与使用解耦
  客户端只负责使用对象，对象根据不同场景使用不同的创建模式
  不同场景使用不同的创建逻辑

- 运行时候可插拔
  不用修改client代码，实现不同工厂之间的转变

## 观察者模式
观察者模式（Observer）一句话：“一个对象状态变了，自动通知所有关心它的人，但根本不需要知道这些人是谁。”

微信公众号：作者（被观察者）发文 → 所有订阅者（观察者）微信收到推送，作者不用管粉丝是谁。

网约车：订单状态（被观察）一变，短信、App、司机端、地图 自动刷新，订单中心不直接调用它们。


## 装饰器模式
把“功能”做成可插拔的洋葱皮：
运行时想加就加、想换就换，永远不用改原来的类。

#### 继承爆炸
```
FileStream
├── GzipFileStream
│   ├── GzipEncryptFileStream
│   └── GzipBufferFileStream
├── EncryptFileStream
│   ├── EncryptGzipFileStream
│   └── EncryptBufferFileStream
└── BufferFileStream
    ├── BufferGzipFileStream
    └── BufferEncryptFileStream
```
功能只有 3 个（压缩、加密、缓存），却得到 3²=9 个子类；
再增加“签名、限速、日志”？→ 4³=64 个子类
这就是继承爆炸——组合数爆炸，类数量=功能数量的阶乘


## 状态机模型
当前状态 + 事件 = 下一状态”——
把对象的一生拆成有限个状态，
收到不同事件就按预定规则跳到对应状态，永不迷路。

“状态超过 3 个，且每个状态对同一事件的反应不一样”——
只要出现 巨型 switch 或一堆 if-else 判断状态，
就该用状态机一把梭。




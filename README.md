# design-patter
## 单例模式
✅ 用：全局唯一且状态可共享（日志器、配置表、硬件句柄）。
❌ 避：
– 为了“方便全局访问”而随手单例 → 隐藏依赖，单元测试难。
– 单例里存业务状态 → 并发测试变成“状态地雷”。

现代技巧：
– 优先用 std::call_once/static T 而不是双重检查锁。
– 考虑 constexpr 单例（C++20 constinit）对编译期初始化的场景。

- 使用场景
我们日志器需要全局唯一实例，否则多线程写同一个文件会相互覆盖；
同时它在整个进程生命周期都要存在，所以用单例管理最合适

- 测试友好
“单例一旦初始化就无法重置，单元测试之间会互相污染。
加了一个 测试专用 reset 接口，只在编译宏 UNIT_TEST 时暴露，
这样每条测试用例都能拿到全新实例，CI 跑并行 job 也安全。”

- 反模式”自检
单例如果存业务状态或被到处直接拿，就会变成隐形全局变量，
所以只把单例用在 无业务状态、只负责***功能聚合***的类上

## 工厂模式
“把对象创建和使用解耦，让变化只关在一扇门里，其余代码永远开闭原则。”

#### 什么时候“值得”上工厂
创建逻辑可能变化
- 跨平台：Win/Linux/Mac 按钮
- 多数据源：MySQL/PostgreSQL/Oracle 连接
- 运行时决定：根据配置或用户输入选具体类

创建过程复杂，调用者只关心接口
- 需要参数校验、对象池、缓存、代理包装、埋点统计……
- 一句话：“new 完还得做一堆额外工序”

#### 工厂模式的特点
- 创建与使用解耦
客户端只负责使用对象，对象根据不同场景使用不同的创建模式
不同场景使用不同的创建逻辑

- 运行时候可插拔
不用修改client代码，实现不同工厂之间的转变

